# Language Specification (MiniCompiler)

## 1. Lexical Grammar (EBNF)

The lexical structure of the language is defined by the following rules.
Whitespace and comments are ignored by the scanner.

### 1.1 Basic Symbols
letter = 'a' | ... | 'z' | 'A' | ... | 'Z';
digit = '0' | ... | '9';
any_char = any valid UTF-8 character;

### 1.2 Whitespace & Comments
Whitespace characters are skipped. Comments are treated as whitespace.

whitespace = ' ' | '\t' | '\r' | '\n';
comment = single_line_comment | multi_line_comment;
single_line_comment = "//" { any_char_except_newline } '\n';
multi_line_comment = "/*" { any_char | '\n' } "*/";

### 1.3 Identifiers & Keywords
Identifiers start with a letter or underscore, followed by letters, digits, or underscores.
Keywords are reserved identifiers and cannot be used as variable names.

identifier = (letter | '_') { letter | digit | '_' };
keyword = 'if' | 'else' | 'while' | 'for' | 'int' | 'float' | 'bool' | 'return' | 'true' | 'false' | 'void' | 'struct' | 'fn';

**Constraints:**
- Maximum identifier length: 255 characters.
- Case-sensitive: `Var` and `var` are different.

### 1.4 Literals

#### Integer Literals
Decimal sequence of digits.
Range: [-2^31, 2^31-1] (handled semantically, lexer reads positive sequence).
Negative numbers are parsed as a unary minus operator followed by an integer literal.

integer_literal = digit { digit };

#### Float Literals
Sequence of digits, a dot, and more digits. Must have digits after the dot.

float_literal = digit { digit } '.' digit { digit };

#### String Literals
Double-quoted sequence of characters. Escape sequences supported: \", \\, \n, \t.
Newlines inside strings must be escaped.

string_literal = '"' { character | escape_sequence } '"';
escape_sequence = '\' ('"' | '\' | 'n' | 't');
character = any_char_except_quote_and_backslash;

#### Boolean Literals
Represented by keywords `true` and `false`.

bool_literal = 'true' | 'false';

### 1.5 Operators & Delimiters

#### Arithmetic Operators
arithmetic_op = '+' | '-' | '*' | '/' | '%';

#### Relational Operators
relational_op = "==" | "!=" | '<' | "<=" | '>' | ">=";

#### Logical Operators
logical_op = "&&" | "||" | '!';

#### Assignment Operator
assignment_op = '=';

#### Delimiters
delimiter = '(' | ')' | '{' | '}' | ';' | ',';

### 1.6 Token Structure
A token generated by the scanner consists of:
- **Type**: Enumeration value (e.g., KW_IF, INT_LITERAL, IDENTIFIER).
- **Lexeme**: The original substring from the source code.
- **Position**: Line number (1-based), Column number (1-based).
- **Value**: Parsed semantic value (e.g., integer number, float number, string content without quotes, boolean).

## 2. Character Set & Encoding
- **Encoding**: UTF-8.
- **Line Endings**: Supports Unix (\n) and Windows (\r\n). Carriage returns are normalized.

## 3. Error Handling
- **Invalid Characters**: Trigger an error message with line/column coordinates. The scanner skips the invalid character and continues (recovery mode).
- **Unterminated Strings**: Trigger an error if the closing quote is missing or a newline is encountered unescaped.
- **Unterminated Comments**: Trigger an error if EOF is reached before */.
- **Malformed Numbers**: Trigger an error for invalid sequences (e.g., multiple dots).